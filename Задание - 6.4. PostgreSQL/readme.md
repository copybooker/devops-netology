# Задание - 6.4. PostgreSQL

##        1. Используя docker поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.

Подключитесь к БД PostgreSQL используя psql.

Воспользуйтесь командой \? для вывода подсказки по имеющимся в psql управляющим командам.

Найдите и приведите управляющие команды для:

вывода списка БД
подключения к БД
вывода списка таблиц
вывода описания содержимого таблиц
выхода из psql

### Ответ:
- вывод списка БД 
      \l[+]
- подключение к БД 
      \c[onnect]
- вывод списка таблиц 
      \d[S+] или \dt[S+]
- вывод описания содержимого таблиц 
      \d[S+]  NAME
- выход из psql 
      \q

##        2. Используя psql создайте БД test_database.

Изучите бэкап БД.

Восстановите бэкап БД в test_database.

Перейдите в управляющую консоль psql внутри контейнера.

Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.

Используя таблицу pg_stats, найдите столбец таблицы orders с наибольшим средним значением размера элементов в байтах.

Приведите в ответе команду, которую вы использовали для вычисления и полученный результат.



### Ответ:
Использовал следующую команду
```
postgres=# select MAX(pg_stats.avg_width) from pg_stats;
 max 
-----
 647
(1 row)
```


##       3. Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и поиск по ней занимает долгое время. Вам, как успешному выпускнику курсов DevOps в нетологии предложили провести разбиение таблицы на 2 (шардировать на orders_1 - price>499 и orders_2 - price<=499).

Предложите SQL-транзакцию для проведения данной операции.

Можно ли было изначально исключить "ручное" разбиение при проектировании таблицы orders?

### Ответ:
Сначала провел разбиение на 2 таблицы
```
CREATE TABLE orders_1 (CHECK (price < 499)) INHERITS (orders);
CREATE TABLE orders_2 (CHECK (price >= 499)) INHERITS (orders);
```
Затем перенес в них данные из основной таблицы по заданному условию и очистил основную таблицу
```
INSERT INTO orders_1 SELECT * FROM orders WHERE price < 499;
INSERT INTO orders_2 SELECT * FROM orders WHERE price >= 499;
DELETE FROM only orders where price NOT NULL;
```
Можно ли было изначально исключить "ручное" разбиение при проектировании таблицы orders?

Применить шардирование можно на этапе проектирования базы, если уже есть представление о размере таблиц, но чаще фактически оно проводится уже по факту после переполнения базы.


##        4. Используя утилиту pg_dump создайте бекап БД test_database.

Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца title для таблиц test_database?



### Ответ:
Нужно добавить параметр UNIQUE
```
CREATE TABLE public.orders (
    id integer NOT NULL,
    title character varying(80) UNIQUE NOT NULL,
    price integer DEFAULT 0
);
```
